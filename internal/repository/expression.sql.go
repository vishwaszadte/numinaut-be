// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: expression.sql

package repository

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const filterExpressions = `-- name: FilterExpressions :many
SELECT id, uuid, expression, result, num_operands, difficulty, created_at, updated_at, deleted_at FROM expressions
WHERE (
    CASE
        WHEN $1::text = '=' THEN expression = $2::VARCHAR
        WHEN $1::text = 'in' THEN expression = ANY($3::VARCHAR[])
        WHEN $1::text = 'not in' THEN expression <> ALL($3::VARCHAR[])
        ELSE TRUE
    END
)
AND (
    CASE
        WHEN $4::text = '=' THEN result = $5::REAL
        WHEN $4::text = 'in' THEN result = ANY($6::REAL[])
        WHEN $4::text = 'not in' THEN result <> ALL($6::REAL[])
        ELSE TRUE
    END
)
AND (
    CASE
        WHEN $7::text = '=' THEN num_operands = $8::INT
        WHEN $7::text = 'in' THEN num_operands = ANY($9::INT[])
        WHEN $7::text = 'not in' THEN num_operands <> ALL($9::INT[])
        ELSE TRUE
    END
)
AND (
    CASE
        WHEN $10::text = '=' THEN difficulty = $11::INT
        WHEN $10::text = 'in' THEN difficulty = ANY($12::INT[])
        WHEN $10::text = 'not in' THEN difficulty <> ALL($12::INT[])
        ELSE TRUE
    END
)
AND (
    CASE
        WHEN $13::text = '=' THEN id = $14::INT
        WHEN $13::text = 'in' THEN id = ANY($15::INT[])
        WHEN $13::text = 'not in' THEN id <> ALL($15::INT[])
        ELSE TRUE
    END
)
 AND (
    CASE
        WHEN $16::text = '=' THEN uuid = $17::UUID
        WHEN $16::text = 'in' THEN uuid = ANY($18::UUID[])
        WHEN $16::text = 'not in' THEN uuid <> ALL($18::UUID[])
        ELSE TRUE
    END
)
ORDER BY
    CASE WHEN $19::text = 'id' AND $20::text = 'asc' THEN id END ASC,
    CASE WHEN $19::text = 'id' AND $20::text = 'desc' THEN id END DESC,
    CASE WHEN $19::text = 'created_at' AND $20::text = 'asc' THEN created_at END ASC,
    CASE WHEN $19::text = 'created_at' AND $20::text = 'desc' THEN created_at END DESC,
    CASE WHEN $19::text = 'updated_at' AND $20::text = 'asc' THEN updated_at END ASC,
    CASE WHEN $19::text = 'updated_at' AND $20::text = 'desc' THEN updated_at END DESC,
    CASE WHEN $19::text = 'deleted_at' AND $20::text = 'asc' THEN deleted_at END ASC,
    CASE WHEN $19::text = 'deleted_at' AND $20::text = 'desc' THEN deleted_at END DESC
LIMIT $22::INT
OFFSET $21::INT
`

type FilterExpressionsParams struct {
	ExpressionFilterOp  string      `json:"expression_filter_op"`
	Expression          string      `json:"expression"`
	ExpressionArr       []string    `json:"expression_arr"`
	ResultFilterOp      string      `json:"result_filter_op"`
	Result              float32     `json:"result"`
	ResultArr           []float32   `json:"result_arr"`
	NumOperandsFilterOp string      `json:"num_operands_filter_op"`
	NumOperands         int32       `json:"num_operands"`
	NumOperandsArr      []int32     `json:"num_operands_arr"`
	DifficultyFilterOp  string      `json:"difficulty_filter_op"`
	Difficulty          int32       `json:"difficulty"`
	DifficultyArr       []int32     `json:"difficulty_arr"`
	IDFilterOp          string      `json:"id_filter_op"`
	ID                  int32       `json:"id"`
	IDArr               []int32     `json:"id_arr"`
	UuidFilterOp        string      `json:"uuid_filter_op"`
	Uuid                uuid.UUID   `json:"uuid"`
	UuidArr             []uuid.UUID `json:"uuid_arr"`
	OrderBy             string      `json:"order_by"`
	OrderDirection      string      `json:"order_direction"`
	Offset              pgtype.Int4 `json:"offset"`
	Limit               pgtype.Int4 `json:"limit"`
}

func (q *Queries) FilterExpressions(ctx context.Context, arg FilterExpressionsParams) ([]Expression, error) {
	rows, err := q.db.Query(ctx, filterExpressions,
		arg.ExpressionFilterOp,
		arg.Expression,
		arg.ExpressionArr,
		arg.ResultFilterOp,
		arg.Result,
		arg.ResultArr,
		arg.NumOperandsFilterOp,
		arg.NumOperands,
		arg.NumOperandsArr,
		arg.DifficultyFilterOp,
		arg.Difficulty,
		arg.DifficultyArr,
		arg.IDFilterOp,
		arg.ID,
		arg.IDArr,
		arg.UuidFilterOp,
		arg.Uuid,
		arg.UuidArr,
		arg.OrderBy,
		arg.OrderDirection,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Expression
	for rows.Next() {
		var i Expression
		if err := rows.Scan(
			&i.ID,
			&i.Uuid,
			&i.Expression,
			&i.Result,
			&i.NumOperands,
			&i.Difficulty,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExpressionByID = `-- name: GetExpressionByID :one
SELECT id, uuid, expression, result, num_operands, difficulty, created_at, updated_at, deleted_at FROM expressions
WHERE id = $1
`

func (q *Queries) GetExpressionByID(ctx context.Context, id int32) (Expression, error) {
	row := q.db.QueryRow(ctx, getExpressionByID, id)
	var i Expression
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Expression,
		&i.Result,
		&i.NumOperands,
		&i.Difficulty,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getExpressionByUUID = `-- name: GetExpressionByUUID :one
SELECT id, uuid, expression, result, num_operands, difficulty, created_at, updated_at, deleted_at FROM expressions
WHERE uuid = $1
`

func (q *Queries) GetExpressionByUUID(ctx context.Context, argUuid uuid.UUID) (Expression, error) {
	row := q.db.QueryRow(ctx, getExpressionByUUID, argUuid)
	var i Expression
	err := row.Scan(
		&i.ID,
		&i.Uuid,
		&i.Expression,
		&i.Result,
		&i.NumOperands,
		&i.Difficulty,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}
